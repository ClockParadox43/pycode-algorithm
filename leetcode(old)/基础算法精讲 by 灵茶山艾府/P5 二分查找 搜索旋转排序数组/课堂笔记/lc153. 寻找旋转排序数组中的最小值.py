# 题目链接:
#   https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/
# 题目分析:
#   根据题意可得出，可能是一个递增的数组，也可能是两段递增的数组且第一个数大于最后一个数，如何用O(logn)的题目找出最小值
#
#   需要一个判定方式来判断二分的位置：也就是到底在mid的左侧还是右侧。
#   这里采取和最后一个数字比大小，所以可以分出两种情况：
#       - 最后一个数是最小值
#       - 最后一个数在最小值的右侧
#   因为最小值一定存在于数组中，所以可以[0,n-2]之间比大小（如果序列递减，正好二分到底，结束循环）
#
#   判断二分方式：
#      1. 如果mid<最后一个数（无论哪情况，mid要么是最小值要么在最小值右侧） -> 蓝色
#           - 在一段递增序列中
#                   - 最小值一定是在第一段的左端点位置，如果不是最小值，那么mid一定在最小值的右侧
#           - 在两段递增序列中的第二段中
#                   - 最小值一定是在第二段的左端点位置，如果不是最小值，那么mid一定在最小值的右侧
#           由于是在[0,n-2]中二分，必不会等于最后一个数
#
#      2. 如果mid>最后一个数   -> 红色
#           - 必定不会现在一段递增子序列中
#           - 最后一个数是第二段最大的，所以必定会出现在以第一段子序列中
#                  - 因为最小值在第二段左端点，所以mid一定在最小值左侧

from typing import List

class Solution:
    def findMin(self, nums: List[int]) -> int:
        l = -1; r = len(nums) - 1;
        while (l + 1 < r):
            m = (l + r) // 2;
            if (nums[m] < nums[-1]): r = m;     # 蓝色
            else: l = m;                        # 红色
        return nums[r];
